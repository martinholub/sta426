mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols <- rainbow(length(unique(mycl)))
# create vector of colors for side bar
myClusterSideBar <- clusterCols[mycl]
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = myClusterSideBar, pch = 16)
names = c("norm", "sick", "acute")
legend(legend = names, col = clusterCols, lwd = 1, cex = 0.75,
y.intersp = 0.75, ncol = 1)
?legend
# Do multidimensional scaling
x_mds = cmdscale(dist_fun(x_norm), k = 2)
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols <- rainbow(length(unique(mycl)))
# create vector of colors for side bar
myClusterSideBar <- clusterCols[mycl]
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = myClusterSideBar, pch = 16)
names = c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols, lwd = 1, cex = 0.75,
y.intersp = 0.75, ncol = 1)
# Do multidimensional scaling
x_mds = cmdscale(dist_fun(x_norm), k = 2)
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols <- rainbow(length(unique(mycl)))
# create vector of colors for side bar
myClusterSideBar <- clusterCols[mycl]
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = myClusterSideBar, pch = 16)
names = c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols, lwd = 1, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
# Do multidimensional scaling
x_mds = cmdscale(dist_fun(x_norm), k = 2)
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols <- rainbow(length(unique(mycl)))
# create vector of colors for side bar
myClusterSideBar <- clusterCols[mycl]
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = myClusterSideBar, pch = 16)
names = c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
# Do multidimensional scaling
x_mds = cmdscale(dist_fun(x_norm), k = 2)
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols <- rainbow(length(unique(mycl)))
# create vector of colors for side bar
myClusterSideBar <- clusterCols[mycl]
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = myClusterSideBar, pch = 16)
names = c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols, cex = 1.5,
y.intersp = 0.75, ncol = 1, pch = 16)
# Do multidimensional scaling
x_mds = cmdscale(dist_fun(x_norm), k = 2)
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols <- rainbow(length(unique(mycl)))
# create vector of colors for side bar
myClusterSideBar <- clusterCols[mycl]
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = myClusterSideBar, pch = 16)
names = c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
# Do multidimensional scaling
x_mds = cmdscale(dist_fun(x_norm), k = 2)
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols <- rainbow(length(unique(mycl)))
# create vector of colors for side bar
myClusterSideBar <- clusterCols[mycl]
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = myClusterSideBar, pch = 16)
names = c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
?pca
?prcomp
x_pca = prcomp(x_norm, center = TRUE, scale = TRUE, rank = 2)
plot(x_pca, main = "PCA of expression levels", col = clusterCols, pch = 16)
?princomp
list[sdevs, x_rotated, x_transformed, center, scale] = prcomp(x_norm, center = TRUE, scale = TRUE, rank = 2)
list[sdev, rotation, x, center, scale] = prcomp(x_norm, center = TRUE, scale = TRUE, rank = 2)
list[sdev, rotation, x_transformed, center, scale] <- prcomp(x_norm, center = TRUE, scale = TRUE, rank = 2)
#list[sdev, rotation, x_transformed, center, scale]
ret <- prcomp(x_norm, center = TRUE, scale = TRUE, rank = 2)
plot(ret, main = "PCA of expression levels", col <- clusterCols, pch = 16)
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols_unique <- rainbow(length(unique(mycl)))
# create vector of colors for side bar
clusterCols <- clusterCols_unique[mycl]
# Do multidimensional scaling
x_mds <- cmdscale(dist_fun(x_norm), k = 2)
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = clusterCols, pch = 16)
names <. c("norm", "sick", "acute")
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols_unique <- rainbow(length(unique(mycl)))
# create vector of colors for side bar
clusterCols <- clusterCols_unique[mycl]
# Do multidimensional scaling
x_mds <- cmdscale(dist_fun(x_norm), k = 2)
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
ret <- prcomp(x_norm, center = TRUE, scale = TRUE, rank = 2)
plot(ret, main = "PCA of expression levels", col <- clusterCols, pch = 16)
x_norm <- limma::normalizeQuantiles((x))
limma::plotDensities(object = log2(x_norm), col = colors, legend = FALSE,
main ="limma::plotDensities of qNormalized data")
legend("topright", legend = samples, col = colors, lwd = 1, cex = 0.75,
y.intersp = 0.75, ncol = 1)
#list[sdev, rotation, x_transformed, center, scale]
ret = prcomp(x_norm, center = TRUE, scale = TRUE, rank = 2)
plot(ret, main = "PCA of expression levels", col <- clusterCols, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
ret <- prcomp(x = x_norm, center = TRUE, scale = TRUE, rank = 2)
plot(ret, main = "PCA of expression levels", col <- clusterCols, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
ret <- prcomp(x = x_norm, center = TRUE, scale = TRUE, rank = 10)
plot(ret, main = "PCA of expression levels", col <- clusterCols, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
ret <- prcomp(x = x_norm, center = TRUE, scale = TRUE, rank = 2)
plot(ret, main = "PCA of expression levels", col <- clusterCols, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
ret <- prcomp(x = x_norm, center = TRUE, scale = TRUE, rank = 2)
plot(ret, main = "PCA of expression levels", col = clusterCols, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
list[sdevs, x_rot, x_scal, cent, scal] <- prcomp(x = x_norm, center = TRUE, scale = TRUE, rank = 2)
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$x[,1:2], main = "PCA of expression levels", col = clusterCols, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$rotation[,1:2], main = "PCA of expression levels", col = clusterCols, pch = 16)
plot(pca_res$sdev, type = 'l', main = 'Variance explained by given PC', xlab = "# of PC")
tot_var = sum(pca_res$sdev)
tot_var
tot_var = sum(pca_res$sdev)
explained_var = pca_res$sdev / tot_var * 100
plot(explained_var, type = 'l', main = 'Variance explained by given PC', xlab = "# of PC", ylab = "% of explained variance")
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2(x_norm, distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), Colv = "Rowv",
labCol = "", labRow = samples,
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
# pheatmap::pheatmap(x_norm, main = "HeatMap",
#                    #clustering_distance_rows = dist_fun,
#                    #clustering_distance_cols = dist_fun,
#                    clustering_method = "ward.D",
#                    color = colorRampPalette(c('green', 'orange'))(100),
#                    annotation_row = samples)
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2(x_norm, distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters),
labCol = "", labRow = samples,
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2(x_norm, distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), colv = "Rowv",
labCol = "", labRow = samples,
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2(x_norm, distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), Colv = "Rowv",
labCol = "", labRow = samples,
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
# pheatmap::pheatmap(x_norm, main = "HeatMap",
#                    #clustering_distance_rows = dist_fun,
#                    #clustering_distance_cols = dist_fun,
#                    clustering_method = "ward.D",
#                    color = colorRampPalette(c('green', 'orange'))(100),
#                    annotation_row = samples)
max(x_corr)
min(x_corr)
mycl
clusterCols
unique(mycl)
?vecotr
?vector
clusterCols <- vector(mode = "character", length =length(mycl))
clusterCols[mycl == 1 ] <- clusterCols_unique[1]
clusterCols
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols_unique <- rainbow(length(unique(mycl)))
# create vector of colors for legend
clusterCols <- vector(mode = "character", length =length(mycl))
clusterCols[mycl == 1 ] <- clusterCols_unique[1]
clusterCols[mycl == 2 ] <- clusterCols_unique[2]
clusterCols[mycl == 3 ] <- clusterCols_unique[3]
# Do multidimensional scaling
x_mds <- cmdscale(dist_fun(x_norm), k = 2)
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
clusterCols
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$rotation[,1:2], main = "PCA of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
legend("topright",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$rotation[,1:2], main = "PCA of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$rotation[,1:2], main = "PCA of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("topright",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$rotation[,2:3], main = "PCA of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("topright",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$rotation[,1:2], main = "PCA of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("topright",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$rotation[,1:2], main = "PCA of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("topright",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
knitr::opts_chunk$set(echo = TRUE)
anno = read.table("SampleAnnotation.txt", as.is=TRUE, sep="\t",
quote="", row.names=1, header=TRUE)
x = read.table("expressionData.txt", as.is=TRUE, sep="\t",
quote="", row.names=1, header=TRUE, check.names = FALSE)
x = as.matrix(x)
samples = rownames(anno)
colors = rainbow(nrow(anno))
isNorm = anno$TissueType == "norm"
isSick = anno$TissueType == "sick"
isAcute = anno$TissueType == "acute"
boxplot(log2(x), las = 2, main = "Boxplot", use.cols = TRUE)
for (i in 1:dim(x)[2]){
df = density(log2(x[, i]), bw ="SJ", kernel= "gauss", na.rm = TRUE)
color = colors[i]
name = samples[i]
if (i == 1){
plot(df, col = color, main = "Kernel Density Estimation")
} else {
lines(df, col = color)
} }
legend("topright", legend = samples, col = colors, lwd = 1, cex = 0.75,
y.intersp = 0.75, ncol = 1)
limma::plotDensities(object = log2(x), col = colors, legend = FALSE,
main = "limma::PlotDensities")
legend("topright", legend = samples, col = colors, lwd = 1, cex = 0.75,
y.intersp = 0.75, ncol = 1)
x_norm <- limma::normalizeQuantiles((x))
limma::plotDensities(object = log2(x_norm), col = colors, legend = FALSE,
main ="limma::plotDensities of Quantile Normalized data")
legend("topright", legend = samples, col = colors, lwd = 1, cex = 0.75,
y.intersp = 0.75, ncol = 1)
# dist_measure <- as.dist((1-cor(log2(x))))
dist_fun <-function(data){
# Distance measure based on correlation of log2 transformed data
data_log2 = log2(data)
return(as.dist((1-cor((data_log2)))))
}
clusters <- hclust(dist_fun(x_norm), method = "ward.D")
plot(clusters)
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2(x_norm, distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), Colv = "Rowv",
labCol = "", labRow = samples,
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
# We may also use different functions to obtain similar results
# pheatmap::pheatmap(x_norm, main = "HeatMap",
#                    #clustering_distance_rows = dist_fun,
#                    #clustering_distance_cols = dist_fun,
#                    clustering_method = "ward.D",
#                    color = colorRampPalette(c('green', 'orange'))(100),
#                    annotation_row = samples)
# First, generate some color palette. Later may spend some time to find color-blinded friendly one.
cor_palette = colorRampPalette(c("white", "blue"))(n = 100)
x_corr = cor(log2(x_norm))
image(x=seq(nrow(x_corr)), y=seq(ncol(x_corr)), z=x_corr,
main = "correlation matrix", col = cor_palette,
xlab = "", ylab = "", axes = F)
axis(1, at=seq(nrow(x_corr)), labels = samples, las=2)
axis(2, at=seq(ncol(x_corr)), labels = samples, las=1)
corrplot::corrplot(x_corr, title = "Correlation Matrix",
method = "color", cl.pos="b")
heatmap(x_corr, main = "Correlation Heatmap", col = cor_palette,
distfun = dist_fun)
# Get cluster membership from previous clustering
mycl <- cutree(clusters, h=max(clusters$height/4))
#Define Coloring
clusterCols_unique <- rainbow(length(unique(mycl)))
# create vector of colors for legend
clusterCols <- vector(mode = "character", length =length(mycl))
clusterCols[mycl == 1 ] <- clusterCols_unique[1]
clusterCols[mycl == 2 ] <- clusterCols_unique[2]
clusterCols[mycl == 3 ] <- clusterCols_unique[3]
# Do multidimensional scaling
x_mds <- cmdscale(dist_fun(x_norm), k = 2)
plot(x_mds, main = "Multi-dimensional scaling of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("top",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$rotation[,1:2], main = "PCA of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("topright",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
#list[sdev, rotation, x_transformed, center, scale]
pca_res <- prcomp(x = x_norm, center = TRUE, scale = TRUE)
plot(pca_res$rotation[,2:3], main = "PCA of expression levels", col = clusterCols, pch = 16)
names <- c("norm", "sick", "acute")
legend("topright",legend = names, col = clusterCols_unique, cex = 0.75,
y.intersp = 0.75, ncol = 1, pch = 16)
tot_var = sum(pca_res$sdev)
explained_var = pca_res$sdev / tot_var * 100
plot(explained_var, type = 'l', main = 'Variance explained by given PC', xlab = "# of PC", ylab = "% of explained variance")
x_norm_sample = x_norm[sample(nrow(df), 5),]
x_norm_sample = x_norm[sample(nrow(x_norm), 5),]
clusters <- hclust(dist_fun(t(x_norm_sample)), method = "ward.D")
plot(clusters)
x_norm_sample = x_norm[sample(nrow(x_norm), 1000),]
clusters <- hclust(dist_fun(t(x_norm_sample)), method = "ward.D")
plot(clusters)
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2(t(x_norm_sample), distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), Colv = "Rowv",
labCol = "", labRow = samples,
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2(t(x_norm_sample), distfun = dist_fun,
dendrogram = "column",
Rowv = as.dendrogram(clusters), Colv = "Rowv",
labCol = "", labRow = samples,
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2(t(x_norm_sample), distfun = dist_fun,
dendrogram = "column",
Rowv = as.dendrogram(clusters), Colv = "Rowv",
labCol = "", labRow = "samples",
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
as.dendrogram(clusters)
dist = dist_fun(t(x_norm_sample)
)
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2(t(x_norm_sample), distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), Colv = "Rowv",
labCol = "", labRow = "",
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2((x_norm_sample), distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), Colv = "Rowv",
labCol = "", labRow = "",
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
indices = sample(nrow(x_norm), 1000)
indices = sample(nrow(x_norm), 1000)
indices = sample(nrow(x_norm), 1000)
x_norm_sample = x_norm[indices,]
clusters <- hclust(dist_fun(t(x_norm_sample)), method = "ward.D")
plot(clusters)
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2((x_norm_sample), distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters),
labCol = "", labRow = samples[indices],
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2((x_norm_sample), distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), Colv = FALSE
labCol = "", labRow = samples[indices],
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2((x_norm_sample), distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), Colv = FALSE,
labCol = "", labRow = samples[indices],
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
# First, generate some color palette. Later may spend some time to find color-blinded friendly one.
cor_palette = colorRampPalette(c("white", "blue"))(n = 100)
x_corr = cor(log2(t(x_norm_sample)))
corrplot::corrplot(x_corr, title = "Correlation Matrix",
method = "color", cl.pos="b")
corrplot::corrplot(x_corr, title = "Correlation Matrix",
method = "color", cl.pos="n")
# Do multidimensional scaling
x_mds <- cmdscale(dist_fun(t(x_norm_sample)), k = 2)
plot(x_mds, main = "Multi-dimensional scaling of expression levels", pch = 16)
pca_res <- prcomp(x = t(x_norm_sample), center = TRUE, scale = TRUE)
plot(pca_res$rotation[,1:2], main = "PCA of expression levels", pch = 16)
tot_var = sum(pca_res$sdev)
explained_var = pca_res$sdev / tot_var * 100
plot(explained_var, type = 'l', main = 'Variance explained by given PC', xlab = "# of PC", ylab = "% of explained variance")
?apply
?order
nv <- apply(x_norm, MARGIN = , FUN = var)
nv <- apply(x_norm, MARGIN = 1, FUN = var)
x_norm_sample = head( x_norm[order(nv, decreasing = TRUE),] , 1000 )
sample_names = samples[order(nv, decreasing = TRUE),], 1000 )
nv <- apply(x_norm, MARGIN = 1, FUN = var)
x_norm_sample = head( x_norm[order(nv, decreasing = TRUE),] , 1000 )
sample_names = head(samples[order(nv, decreasing = TRUE),], 1000 )
nv <- apply(x_norm, MARGIN = 1, FUN = var)
x_norm_sample = head( x_norm[order(nv, decreasing = TRUE),] , 1000 )
sample_names = head(samples[order(nv, decreasing = TRUE)], 1000 )
#indices = sample(nrow(x_norm), 1000)
# x_norm_sample = x_norm[indices,]
clusters <- hclust(dist_fun(t(x_norm_sample)), method = "ward.D")
plot(clusters)
my_palette <- colorRampPalette(c("orange", "red"))(n = 100)
gplots::heatmap.2((x_norm_sample), distfun = dist_fun,
dendrogram = "row",
Rowv = as.dendrogram(clusters), Colv = FALSE,
labCol = "", labRow = sample_names,
density.info="none",
col = my_palette,
trace = "none",
scale = "none",
main = "Expression Heatmap")
# First, generate some color palette. Later may spend some time to find color-blinded friendly one.
cor_palette = colorRampPalette(c("white", "blue"))(n = 100)
x_corr = cor(log2(t(x_norm_sample)))
corrplot::corrplot(x_corr, title = "Correlation Matrix",
method = "color", cl.pos="b", tl.pos="n")
# Do multidimensional scaling
x_mds <- cmdscale(dist_fun(t(x_norm_sample)), k = 2)
plot(x_mds, main = "Multi-dimensional scaling of expression levels", pch = 16)
pca_res <- prcomp(x = t(x_norm_sample), center = TRUE, scale = TRUE)
plot(pca_res$rotation[,1:2], main = "PCA of expression levels", pch = 16)
tot_var = sum(pca_res$sdev)
explained_var = pca_res$sdev / tot_var * 100
plot(explained_var, type = 'l', main = 'Variance explained by given PC', xlab = "# of PC", ylab = "% of explained variance")
