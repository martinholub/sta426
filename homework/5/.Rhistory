# fc_pr <- (coeffs["present48"] - coeffs["present10"]) / coeffs["present48"]
# logfc_pr <- log2(fc_pr)
log2(fc_ab)
logfc_ab
#solve overdetermined system of linear equations with some highly DF gene
# https://support.bioconductor.org/p/69464/
# We look at differences in time
coeffs <- qr.solve(design, eset@assayData$exprs["910_at", ])
aver_exprs <- mean(coeffs)
aver_exprs
# https://en.wikipedia.org/wiki/Fold_change
# Find foldchanges and log fold changes
fc_ab <- (coeffs["present10"]) / coeffs["absent10"]
logfc_ab <-mean(log2(coeffs["present10"])) - mean(log2(coeffs["absent10"]))
fc_ab
logfc_ab
round(logfc_ab, 3) == round(log2(fc_ab), 3)
# fc_pr <- (coeffs["present48"] - coeffs["present10"]) / coeffs["present48"]
# logfc_pr <- log2(fc_pr)
design
cont.matrix
coeffs
dim(design)
desing
design
contr.treatment()
contr.treatment(design)
dim(contr.treatment(design))
cont.matrix
mean(log2(eset@assayData$exprs[, "present10"]))
colanmes(eset@assayData$exprs)
colnames(eset@assayData$exprs)
targets
gnames<- paste(targets$estrogen,targets$time.h,sep="")
gnames
#solve overdetermined system of linear equations with some highly DF gene
# https://support.bioconductor.org/p/69464/
gnames<- paste(targets$estrogen,targets$time.h,sep="")
colnames(eset@assayData$exprs) <- gnames
f
colnames(eset@assayData$exprs)
gnames
mean(log2(eset@assayData$exprs[, c("low10-1.cel", "low10-2.cel" )]))
mean(log2(eset@assayData$exprs[, c("high10-1.cel", "high10-2.cel" )]))
avr_exprs
aver_exprs
9.66/2.8
log2(9.66)/2.8
log2(mean(eset@assayData$exprs[, c("high10-1.cel", "high10-2.cel" )]))
log2(mean(eset@assayData$exprs[, c("low10-1.cel", "low10-2.cel" )]))
coeffs["present10"])
coeffs["present10"]
coeffs["absent10"]
log2(11.7)-log2(8.58)
1/0.447
barplot( exprs(eset)["910_at",], las=2, cex.names=.7 )  # top gene
cont.matrix
#solve overdetermined system of linear equations with some highly DF gene
# https://support.bioconductor.org/p/69464/
gnames<- paste(targets$estrogen,targets$time.h,sep="")
# We look at differences in time
coeffs <- qr.solve(design, eset@assayData$exprs["910_at", ])
aver_exprs <- mean(coeffs)
# https://en.wikipedia.org/wiki/Fold_change
# Find foldchanges and log fold changes
base
#solve overdetermined system of linear equations with some highly DF gene
# https://support.bioconductor.org/p/69464/
gnames<- paste(targets$estrogen,targets$time.h,sep="")
# We look at differences in time
coeffs <- qr.solve(design, eset@assayData$exprs["910_at", ])
aver_exprs <- mean(coeffs)
# https://en.wikipedia.org/wiki/Fold_change
# Find foldchanges and log fold changes
fc_ab <- (coeffs["present48"]) / coeffs["absent48"]
logfc_ab <-mean(log2(coeffs["absent48"])) - mean(log2(coeffs["present48"]))
fc_ab
logfc_ab
round(logfc_ab, 3) == round(log2(fc_ab), 3)
# fc_pr <- (coeffs["present48"] - coeffs["present10"]) / coeffs["present48"]
# logfc_pr <- log2(fc_pr)
#solve overdetermined system of linear equations with some highly DF gene
# https://support.bioconductor.org/p/69464/
gnames<- paste(targets$estrogen,targets$time.h,sep="")
# We look at differences in time
coeffs <- qr.solve(design, eset@assayData$exprs["910_at", ])
aver_exprs <- mean(coeffs)
# https://en.wikipedia.org/wiki/Fold_change
# Find foldchanges and log fold changes
fc_ab <- (coeffs["absent48"]) / coeffs["present48"]
logfc_ab <-mean(log2(coeffs["absent48"])) - mean(log2(coeffs["present48"]))
fc_ab
logfc_ab
round(logfc_ab, 3) == round(log2(fc_ab), 3)
# fc_pr <- (coeffs["present48"] - coeffs["present10"]) / coeffs["present48"]
# logfc_pr <- log2(fc_pr)
aver_exprs
coeffs
mean(log2(eset@assayData$exprs[, c("high48-1.cel", "high48-2.cel" )]))
mean(log2(eset@assayData$exprs[, c("low48-1.cel", "low48-2.cel" )]))
min(log2(eset@assayData$exprs[, c("low48-1.cel", "low48-2.cel" )]))
min(log2(eset@assayData$exprs[, c("high48-1.cel", "high48-2.cel" )]))
aver_expr/2.08
aver_exprs/2.08
aver_exprs/2.095
log(aver_exprs)
log2(aver_exprs)
log2(11.106246)
?decideTests()
limma::decideTests(fit2)
?vennDiagram
test_res <- limma::decideTests(fit2, method = "separate", p.value = 0.05, lfc = 0)
# An object of class TestResults. This is essentially a numeric matrix with elements -1, 0 or 1 depending on whether each t-statistic is classified as significantly negative, not significant or significantly positive.
limma::vennDiagram(test_res, include = "both")
test_res <- limma::decideTests(fit2, method = "separate", p.value = 0.05, lfc = 1)
# An object of class TestResults. This is essentially a numeric matrix with elements -1, 0 or 1 depending on whether each t-statistic is classified as significantly negative, not significant or significantly positive.
limma::vennDiagram(test_res, include = "both")
test_res <- limma::decideTests(fit2, method = "separate", p.value = 0.05, lfc = 0)
# An object of class TestResults. This is essentially a numeric matrix with elements -1, 0 or 1 depending on whether each t-statistic is classified as significantly negative, not significant or significantly positive.
limma::vennDiagram(test_res, include = "both")
design
cont.matrix
model.matrix(f)
f
f <- paste(targets$estrogen,targets$time.h,sep="")
f <- factor(f)
design <- model.matrix(+f)
design <- model.matrix(~0)
design
design <- model.matrix(f)
design <- model.matrix(~f)
design
# do the limma modeling
f <- paste(targets$estrogen,targets$time.h,sep="")
f <- factor(f)
# create design matrix
design2 <- model.matrix(~f)
colnames(design2) <- levels(f)
design2
fit <- limma::lmFit(eset, design2)
cont.matrix2 <- makeContrasts(E10="present10-absent10",
E48="present48-absent48",
Time="absent48-absent10",levels=design)
fit <- limma::lmFit(eset, design2)
cont.matrix2 <- makeContrasts(E10="present10-absent10",
E48="present48-absent48",
Time="absent48-absent10",levels=design2)
cont.matrix2
cont.matrix
fit <- limma::lmFit(eset, design2)
cont.matrix2 <- makeContrasts(E10="present10",
E48="present48-absent48",
Time="absent48",levels=design2)
cont.matrix2
targets
levels(f)
fit3 <- limma::lmFit(eset, design2)
# naming doesn"t fit but the math should"
cont.matrix2 <- makeContrasts(E10="present10",
E48="present48-absent48",
Time="absent48",levels=design2)
cont.matrix2
fit4  <- limma::contrasts.fit(fit3, cont.matrix2)
fit4  <- limma::eBayes(fit4, robust = TRUE) # use robust LinReg to deal with outliers
fit4
limma::topTable(fit4,coef=1)
limma::topTable(fit4,coef=2)
limma::topTable(fit4,coef=3)
?design
?model.matrix?
q
?model.matrix
library("limma")
nGenes <- 10000                   # number of "features"
nSamples <- 6                     # number of samples (split equal in 2 groups)
pDiff <- .1                       # percent of genes "differential
grp <- rep(0:1,each=nSamples/2)   # dummy variable for exp. group
trueFC <- 2                       # log-fold-change of truly DE
d0 <- 1
s0 <- 0.8
sd <- s0*sqrt(d0/rchisq(nGenes,df=d0))  # dist'n of s.d.
#hist(sd[sd < (0.9*max(sd))], breaks = 20)
hist(log(sd), breaks = 50)
y <- matrix(rnorm(nGenes*nSamples,sd=sd),
nr=nGenes,nc=nSamples)
indD <- 1:floor(pDiff*nGenes)
diff <- sample(c(-1,1),max(indD),replace=TRUE)*trueFC
y[indD,grp==1] <- y[indD,grp==1] + diff
down_tf <- rep(FALSE, nrow(y))
up_tf <- rep(FALSE, nrow(y))
twosided_tf <- rep(FALSE, nrow(y))
for (row in 1: nrow(y)){ # do it only where differential expression expected
#for (row in 1: length(indD)){
x0 <- y[row, grp == 0]
x1 <- y[row, grp == 1]
res_up <- t.test(x0, x1, alternative = "greater")$p.value
res_down <- t.test(x0, x1, alternative = "less")$p.value
res_twosided <- t.test(x0, x1, alternative = "two.sided")$p.value
if (res_down < .01){
down_tf[row] <- TRUE
}
if (res_up < .01){
up_tf[row] <- TRUE
}
if (res_twosided < .01){
twosided_tf[row] <- TRUE
}
}
upregulated <- y[up_tf, ]
downregulated <- y[down_tf, ]
differential <- y[twosided_tf, ]
nondifferential <- y[indD, ][! twosided_tf[indD], ]
# Note for myself: https://plot.ly/r/parallel-coordinates-plot/
gene_ids <- sample(nrow(differential), 1)
diff_sample <- differential[gene_ids, ]
par(mfrow = c(2, 1))
barplot(diff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Differential")
gene_ids <- sample(nrow(nondifferential), 1)
nondiff_sample <- nondifferential[gene_ids, ]
barplot(nondiff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Nondifferential")
# Note for myself: https://plot.ly/r/parallel-coordinates-plot/
gene_ids <- sample(nrow(differential), 1)
diff_sample <- differential[gene_ids, ]
par(mfrow = c(2, 1))
barplot(diff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Differential")
gene_ids <- sample(nrow(nondifferential), 1)
nondiff_sample <- nondifferential[gene_ids, ]
barplot(nondiff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Nondifferential")
# Note for myself: https://plot.ly/r/parallel-coordinates-plot/
gene_ids <- sample(nrow(differential), 1)
diff_sample <- differential[gene_ids, ]
par(mfrow = c(2, 1))
barplot(diff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Differential")
gene_ids <- sample(nrow(nondifferential), 1)
nondiff_sample <- nondifferential[gene_ids, ]
barplot(nondiff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Nondifferential")
down_tf <- rep(FALSE, nrow(y))
up_tf <- rep(FALSE, nrow(y))
twosided_tf <- rep(FALSE, nrow(y))
for (row in 1: nrow(y)){ # do it only where differential expression expected
#for (row in 1: length(indD)){
x0 <- y[row, grp == 0]
x1 <- y[row, grp == 1]
res_up <- t.test(x0, x1, alternative = "greater")$p.value
res_down <- t.test(x0, x1, alternative = "less")$p.value
res_twosided <- t.test(x0, x1, alternative = "two.sided")$p.value
if (res_down < .05){
down_tf[row] <- TRUE
}
if (res_up < .05){
up_tf[row] <- TRUE
}
if (res_twosided < .05){
twosided_tf[row] <- TRUE
}
}
down_tf <- rep(FALSE, nrow(y))
up_tf <- rep(FALSE, nrow(y))
twosided_tf <- rep(FALSE, nrow(y))
for (row in 1: nrow(y)){ # do it only where differential expression expected
#for (row in 1: length(indD)){
x0 <- y[row, grp == 0]
x1 <- y[row, grp == 1]
res_up <- t.test(x0, x1, alternative = "greater")$p.value
res_down <- t.test(x0, x1, alternative = "less")$p.value
res_twosided <- t.test(x0, x1, alternative = "two.sided")$p.value
if (res_down < .05){
down_tf[row] <- TRUE
}
if (res_up < .05){
up_tf[row] <- TRUE
}
if (res_twosided < .05){
twosided_tf[row] <- TRUE
}
}
upregulated <- y[up_tf, ]
downregulated <- y[down_tf, ]
differential <- y[twosided_tf, ]
nondifferential <- y[indD, ][! twosided_tf[indD], ]
upregulated <- y[up_tf, ]
downregulated <- y[down_tf, ]
differential <- y[twosided_tf, ]
nondifferential <- y[! twosided_tf[indD], ]
# Note for myself: https://plot.ly/r/parallel-coordinates-plot/
gene_ids <- sample(nrow(differential), 1)
diff_sample <- differential[gene_ids, ]
par(mfrow = c(2, 1))
barplot(diff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Differential")
gene_ids <- sample(nrow(nondifferential), 1)
nondiff_sample <- nondifferential[gene_ids, ]
barplot(nondiff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Nondifferential")
# Note for myself: https://plot.ly/r/parallel-coordinates-plot/
gene_ids <- sample(nrow(differential), 1)
diff_sample <- differential[gene_ids, ]
par(mfrow = c(2, 1))
barplot(diff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Differential")
gene_ids <- sample(nrow(nondifferential), 1)
nondiff_sample <- nondifferential[gene_ids, ]
barplot(nondiff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Nondifferential")
# Note for myself: https://plot.ly/r/parallel-coordinates-plot/
gene_ids <- sample(nrow(differential), 1)
diff_sample <- differential[gene_ids, ]
par(mfrow = c(2, 1))
barplot(diff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Differential")
gene_ids <- sample(nrow(nondifferential), 1)
nondiff_sample <- nondifferential[gene_ids, ]
barplot(nondiff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Nondifferential")
# Note for myself: https://plot.ly/r/parallel-coordinates-plot/
gene_ids <- sample(nrow(differential), 1)
diff_sample <- differential[gene_ids, ]
par(mfrow = c(2, 1))
barplot(diff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Differential")
gene_ids <- sample(nrow(nondifferential), 1)
nondiff_sample <- nondifferential[gene_ids, ]
barplot(nondiff_sample, ylab = "FC", xlab = "sample", axes = TRUE, legend.text = gene_ids, names.arg = grp, main = "Nondifferential")
design <- model.matrix(~grp)
fit <- limma::lmFit(y,design)
fit <- limma::eBayes(fit, robust = TRUE)
classicalt <- vector(mode = "numeric", length = nrow(y))
classicalt_res <- list()
data <- list()
for (row in 1: nrow(y)){
x0 <- y[row, grp == 0]
x1 <- y[row, grp == 1]
classicalt[row] <- t.test(x0, x1, alternative = "two.sided")$statistic
classicalt_res <- append(classicalt_res, list(t.test(x0, x1, alternative = "two.sided")))
}
cols <- rep("black",nrow(y))
cols[indD] <- "blue"
par(mfrow=c(3,1))
plot( classicalt, col=cols, ylim=c(-10,10), pch=".", main="Classical-t" )
plot( fit$t[,2], col=cols, ylim=c(-10,10), pch=".", main="Moderated-t" )
plot( fit$coef[,2], col=cols, ylim=c(-6,6), pch=".", main="log FC" )
d1 <- density(classicalt[indD], bw ="SJ", kernel= "gauss", na.rm = TRUE)
d2 <- density(fit$t[indD,2], bw ="SJ", kernel= "gauss", na.rm = TRUE)
colors_t = c("firebrick3", "dodgerblue4")
#h1 <- hist(classicalt[indD], breaks = 20)
#h2 <- hist(fit$t[indD,2], breaks = 20)
#plot( h1, col=colors_t[1], xlim=c(-10,10), main = "Hist of t and t-moderated")
#plot( h2, col=colors_t[2], xlim=c(-10,10), add=T)
plot( d1, col=colors_t[1], xlab = "", main = "Kernel Density estimate")
lines( d2, col=colors_t[2], xlab = "")
legend("topright", legend = c("t-classical", "t-moderated"), col = colors_t, lwd = 1, cex = 0.75,y.intersp = 0.75, ncol = 1)
ssd
length(sum(classicalt[indD] =< 0.05)
(sum(classicalt[indD] =< 0.05)
t_c_indD <- classicalt[indD & classicalt[indD] <.05]
t_c_indD
abs(-3)
p_vals_class <- unlist(lapply(classicalt_res, function (x) x$p.value[[1]]))
p_vals_mod <- fit$p.value[, 2] # why second column?
fc_vals <- abs(fit$coef[, 1] - fit$coef[, 2])
ground_truth <- rep(0, nrow(y))
ground_truth[1:max(indD)] <- rep(1, max(indD))
colors_roc = c("firebrick3", "dodgerblue4", "forestgreen")
library(ROCR)
samp_sizes <- seq(2*max(indD), nrow(y), by = 2*length(indD))
perf_class_container <- list()
perf_mod_container <- list()
for (it in 5){
idxer <- rep(FALSE, nrow(y))
samp_size <- samp_sizes[it]
idxer[1: samp_size] <- rep(TRUE, samp_size)
pred_class <- prediction(1 - p_vals_class[idxer], ground_truth[idxer])
pred_mod <- prediction(1 - p_vals_mod[idxer], ground_truth[idxer])
pred_fc <- prediction(fc_vals[idxer], ground_truth[idxer]*trueFC)
perfc <- performance(pred_class, measure = "tpr", x.measure = "fpr")
aucc <- performance(pred_class, measure = "auc")
perfm <- performance(pred_mod, measure = "tpr", x.measure = "fpr")
aucm <- performance(pred_mod, measure = "auc")
perffc <-performance(pred_fc, measure = "tpr", x.measure = "fpr")
aucfc <- performance(pred_fc, measure = "auc")
#perfc <- sum((p_vals_class[idxer] > thresh)) / samp_size # TP
#perfm <- sum((p_vals_mod[idxer] > thresh)) / samp_size # TP
#perf_class_container <- append(perf_class_container, perfc)
#perf_mod_container <- append(perf_mod_container, perfm)
plot(perfc, col = colors_roc[1])
abline(a=0, b= 1)
plot(perfm, add = TRUE, col = colors_roc[2])
plot(perffc, add = TRUE, col = colors_roc[3])
leg1 <- sprintf("t-classical, auc = %1.3f", round(unlist(aucc@y.values), 3))
leg2 <- sprintf("t-moderated, auc = %1.3f", round(unlist(aucm@y.values), 3))
leg3 <- sprintf("t-moderated, auc = %1.3f", round(unlist(aucfc@y.values), 3))
legend("bottomright", legend = c(leg1, leg2, leg3), col = colors_roc, lwd = 1, cex = 1,y.intersp = 1, ncol = 1)
}
#plot(samp_sizes[1:it], ylim = c(0.9, 1.1), perf_class_container, col = "red")
#points(samp_sizes[1:it], perf_mod_container, col = "blue")
fit$coef
library(ROCR)
samp_sizes <- seq(2*max(indD), nrow(y), by = 2*length(indD))
perf_class_container <- list()
perf_mod_container <- list()
for (it in 5){
idxer <- rep(FALSE, nrow(y))
samp_size <- samp_sizes[it]
idxer[1: samp_size] <- rep(TRUE, samp_size)
pred_class <- prediction(1 - p_vals_class[idxer], ground_truth[idxer])
pred_mod <- prediction(1 - p_vals_mod[idxer], ground_truth[idxer])
pred_fc <- prediction(fc_vals[idxer], ground_truth[idxer]*trueFC)
perfc <- performance(pred_class, measure = "tpr", x.measure = "fpr")
aucc <- performance(pred_class, measure = "auc")
perfm <- performance(pred_mod, measure = "tpr", x.measure = "fpr")
aucm <- performance(pred_mod, measure = "auc")
perffc <-performance(pred_fc, measure = "tpr", x.measure = "fpr")
aucfc <- performance(pred_fc, measure = "auc")
#perfc <- sum((p_vals_class[idxer] > thresh)) / samp_size # TP
#perfm <- sum((p_vals_mod[idxer] > thresh)) / samp_size # TP
#perf_class_container <- append(perf_class_container, perfc)
#perf_mod_container <- append(perf_mod_container, perfm)
plot(perfc, col = colors_roc[1])
abline(a=0, b= 1)
plot(perfm, add = TRUE, col = colors_roc[2])
plot(perffc, add = TRUE, col = colors_roc[3])
leg1 <- sprintf("t-classical, auc = %1.3f", round(unlist(aucc@y.values), 3))
leg2 <- sprintf("t-moderated, auc = %1.3f", round(unlist(aucm@y.values), 3))
leg3 <- sprintf("log2-fold change, auc = %1.3f", round(unlist(aucfc@y.values), 3))
legend("bottomright", legend = c(leg1, leg2, leg3), col = colors_roc, lwd = 1, cex = 1,y.intersp = 1, ncol = 1)
}
#plot(samp_sizes[1:it], ylim = c(0.9, 1.1), perf_class_container, col = "red")
#points(samp_sizes[1:it], perf_mod_container, col = "blue")
#solve overdetermined system of linear equations with some highly DF gene
# https://support.bioconductor.org/p/69464/
gnames<- paste(targets$estrogen,targets$time.h,sep="")
library("limma")
library("affy")
library("preprocessCore")
unzip("affy_estrogen.zip")
ddir <- "affy_estrogen"
dir(ddir)
library("limma")
library("affy")
library("preprocessCore")
unzip("affy_estrogen.zip")
ddir <- "affy_estrogen"
dir(ddir)
# preprocess affymetrix data
targets <- limma::readTargets("targets.txt", path=ddir)
targets
abatch <- affy::ReadAffy(filenames=targets$filename,
celfile.path=ddir)
eset <- affy::rma(abatch)  # bg correct, normalize, summarize
limma::plotMDS( Biobase::exprs(eset) )  # MDS plot
# do the limma modeling
f <- paste(targets$estrogen,targets$time.h,sep="")
f <- factor(f)
# create design matrix
design <- model.matrix(~0+f)
colnames(design) <- levels(f)
design
fit <- limma::lmFit(eset, design)
cont.matrix <- makeContrasts(E10="present10-absent10",
E48="present48-absent48",
Time="absent48-absent10",levels=design)
cont.matrix
fit2  <- limma::contrasts.fit(fit, cont.matrix)
fit2  <- limma::eBayes(fit2, robust = TRUE) # use robust LinReg to deal with outliers
fit2
class(fit2)
names(fit2)
limma::topTable(fit2,coef=1)
limma::topTable(fit2,coef=2)
limma::topTable(fit2,coef=3)
barplot( exprs(eset)["910_at",], las=2, cex.names=.7 )  # top gene
barplot( exprs(eset)["AFFX-CreX-5_at",], las=2, cex.names=.7 )  # top gene in time
#confirmed
#solve overdetermined system of linear equations with some highly DF gene
# https://support.bioconductor.org/p/69464/
gnames<- paste(targets$estrogen,targets$time.h,sep="")
# We look at some top differentially expressed gene from either E10, E48 or Time contrasts.
coeffs <- qr.solve(design, eset@assayData$exprs["910_at", ])
aver_exprs <- mean(coeffs)
aver_exprs # OK
# https://en.wikipedia.org/wiki/Fold_change
# Find foldchanges and log fold changes
logfc_ab <-mean((coeffs["absent48"])) - mean((coeffs["present48"]))
logfc_ab # Not OK
#mean(log2(eset@assayData$exprs[, c("high48-1.cel", "high48-2.cel" )]))
#solve overdetermined system of linear equations with some highly DF gene
# https://support.bioconductor.org/p/69464/
gnames<- paste(targets$estrogen,targets$time.h,sep="")
# We look at some top differentially expressed gene from either E10, E48 or Time contrasts.
coeffs <- qr.solve(design, eset@assayData$exprs["910_at", ])
aver_exprs <- mean(coeffs)
aver_exprs # OK
# https://en.wikipedia.org/wiki/Fold_change
# Find foldchanges and log fold changes
logfc_ab <-mean((coeffs["present48"])) - mean((coeffs["absent48"]))
logfc_ab # Not OK
#mean(log2(eset@assayData$exprs[, c("high48-1.cel", "high48-2.cel" )]))
test_res <- limma::decideTests(fit2, method = "separate", p.value = 0.05, lfc = 0)
# An object of class TestResults. This is essentially a numeric matrix with elements -1, 0 or 1 depending on whether each t-statistic is classified as significantly negative, not significant or significantly positive.
limma::vennDiagram(test_res, include = "both")
# do the limma modeling
f <- paste(targets$estrogen,targets$time.h,sep="")
f <- factor(f)
# create design matrix
design2 <- model.matrix(~f)
colnames(design2) <- levels(f)
design2 # naming doesn't fit but the math will
fit3 <- limma::lmFit(eset, design2)
cont.matrix2 <- makeContrasts(E10="present10",
E48="present48-absent48",
Time="absent48",levels=design2)
cont.matrix2
fit4  <- limma::contrasts.fit(fit3, cont.matrix2)
fit4  <- limma::eBayes(fit4, robust = TRUE) # use robust LinReg to deal with outliers
#fit4
limma::topTable(fit4,coef=1)
limma::topTable(fit4,coef=2)
limma::topTable(fit4,coef=3)
# Reproduced
